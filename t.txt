--- FILE: js/app.js ---
import { KeyManager } from './modules/keyManager.js';
import { CryptoOps } from './modules/cryptoOps.js';
import { SignVerify } from './modules/signVerify.js';
import { Encrypt } from './modules/encrypt.js';
import { Decrypt } from './modules/decrypt.js';
import { Validation } from './utils/validation.js';
import { Formatting } from './utils/formatting.js';
import { Clipboard } from './utils/clipboard.js';

export class App {
    constructor() {
        this.keyManager = null;
        this.cryptoOps = null;
        this.signVerify = null;
        this.encrypt = null;
        this.decrypt = null;
        this.isInitialized = false;
    }

    // Initialize the application
    async init() {
        try {
            console.log('Initializing OpenPGP.js web PKI Demo...');

            // Check if OpenPGP.js is loaded
            if (typeof openpgp === 'undefined') {
                throw new Error('OpenPGP.js library not loaded');
            }

            console.log('OpenPGP.js version:', openpgp.version || 'Unknown');

            // Initialize core modules
            this.keyManager = new KeyManager();
            this.cryptoOps = new CryptoOps();

            // Initialize operation modules
            this.signVerify = new SignVerify(this.keyManager, this.cryptoOps);
            this.encrypt = new Encrypt(this.keyManager, this.cryptoOps);
            this.decrypt = new Decrypt(this.keyManager, this.cryptoOps);

            // Initialize modules that have init methods
            // Remove: await this.keyManager.init(); // KeyManager doesn't have init method
            if (this.signVerify.init) this.signVerify.init();
            if (this.encrypt.init) this.encrypt.init();
            if (this.decrypt.init) this.decrypt.init();

            // Setup global event listeners
            this.setupGlobalEventListeners();

            // Initialize UI state
            this.updateGlobalUI();

            this.isInitialized = true;
            console.log('OpenPGP.js Demo initialized successfully');

        } catch (error) {
            console.error('Failed to initialize application:', error);
            this.showGlobalError(`Failed to initialize application: ${error.message}`);
        }
    }

    // Setup global event listeners
    setupGlobalEventListeners() {
        // Listen for key events from KeyManager
        document.addEventListener('keysGenerated', (event) => {
            console.log('Keys generated event received:', event.detail);
            this.updateGlobalUI();
        });

        document.addEventListener('keysLoaded', (event) => {
            console.log('Keys loaded event received:', event.detail);
            this.updateGlobalUI();
        });

        document.addEventListener('keysCleared', (event) => {
            console.log('Keys cleared event received');
            this.updateGlobalUI();
        });

        // Global error handling
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            this.handleGlobalError(e.error);
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            this.handleGlobalError(e.reason);
        });

        // Escape key to close modals or reset states
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.handleEscapeKey();
            }
        });
    }

    // Update global UI state
    updateGlobalUI() {
        const hasKeys = this.keyManager?.hasKeys() || false;
        
        // Update all operation modules
        if (this.signVerify && this.signVerify.updateUI) this.signVerify.updateUI();
        if (this.encrypt && this.encrypt.updateUI) this.encrypt.updateUI();
        if (this.decrypt && this.decrypt.updateUI) this.decrypt.updateUI();

        // Update global status indicators
        this.updateGlobalStatus(hasKeys);
    }

    // Update global status indicators
    updateGlobalStatus(hasKeys) {
        // You can add global status updates here if needed
        // For now, individual modules handle their own status
        
        if (hasKeys) {
            console.log('Keys are available - all operations enabled');
        } else {
            console.log('No keys available - operations limited');
        }
    }

    // Handle global errors
    handleGlobalError(error) {
        // Don't show duplicate errors or errors during key generation
        if (this.keyManager?.isGenerating) {
            return;
        }

        console.error('Handling global error:', error);
        
        // Show user-friendly error message
        let errorMessage = 'An unexpected error occurred.';
        if (error && error.message) {
            errorMessage = error.message;
        }

        this.showGlobalError(errorMessage);
    }

    // Show global error message
    showGlobalError(message) {
        // You can implement a global error display here
        // For now, we'll use console and alert as fallback
        console.error('Global error:', message);
        
        // Only show alert for critical errors
        if (message.includes('Failed to initialize') || message.includes('OpenPGP.js library not loaded')) {
            alert(`Critical Error: ${message}\n\nPlease refresh the page and try again.`);
        }
    }

    // Handle escape key presses
    handleEscapeKey() {
        // Close any open modals
        const modal = document.getElementById('advancedOptionsModal');
        if (modal && modal.classList.contains('active')) {
            this.keyManager.hideAdvancedModal();
        }
    }

    // Reset all operations
    resetAll() {
        if (this.signVerify && this.signVerify.reset) this.signVerify.reset();
        if (this.encrypt && this.encrypt.reset) this.encrypt.reset();
        if (this.decrypt && this.decrypt.reset) this.decrypt.reset();
        
        console.log('All operations reset');
    }

    // Get application status
    getStatus() {
        return {
            initialized: this.isInitialized,
            hasKeys: this.keyManager?.hasKeys() || false,
            keyManager: this.keyManager?.getStatus() || null,
            signVerify: this.signVerify?.getStatus() || null,
            encrypt: this.encrypt?.getStatus() || null,
            decrypt: this.decrypt?.getStatus() || null
        };
    }

    // Export current state for debugging
    exportDebugInfo() {
        return {
            timestamp: new Date().toISOString(),
            status: this.getStatus(),
            openpgpVersion: typeof openpgp !== 'undefined' ? (openpgp.version || 'Unknown') : 'Not loaded',
            userAgent: navigator.userAgent,
            hasKeys: this.keyManager?.hasKeys() || false,
            keyInfo: this.keyManager?.getCurrentKeyInfo() || null
        };
    }
}

// Initialize the application when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    console.log('DOM loaded, initializing OpenPGP.js Demo...');
    
    // Create and initialize the main app
    const app = new App();
    await app.init();
    
    // Expose app instance for debugging
    window.OpenPGPDemo = {
        app: app,
        getStatus: () => app.getStatus(),
        exportDebugInfo: () => app.exportDebugInfo(),
        reset: () => app.resetAll()
    };
    
    console.log('OpenPGP.js Demo ready! Access debugging info via window.OpenPGPDemo');
});

--- FILE: js/utils/validation.js ---
import { CONSTANTS } from './constants.js';

export const Validation = {
    // Validate email format
    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    },

    // Validate required form fields for key generation
    validateKeyGenerationFields() {
        const name = document.getElementById('userName').value.trim();
        const email = document.getElementById('userEmail').value.trim();
        const passphrase = document.getElementById('passphrase').value;

        if (!name) {
            throw new Error('Name is required');
        }
        if (!email) {
            throw new Error('Email is required');
        }
        if (!this.isValidEmail(email)) {
            throw new Error(CONSTANTS.ERRORS.INVALID_EMAIL);
        }
        if (!passphrase) {
            throw new Error('Passphrase is required');
        }
        if (passphrase.length < CONSTANTS.MIN_PASSPHRASE_LENGTH) {
            throw new Error(CONSTANTS.ERRORS.PASSPHRASE_TOO_SHORT);
        }

        return { name, email, passphrase };
    },

    // Validate message input
    validateMessage(message) {
        if (!message || message.trim().length === 0) {
            throw new Error('Message cannot be empty');
        }
        return message.trim();
    },

    // Validate PGP message format
    validatePGPMessage(message) {
        const pgpMessageRegex = /-----BEGIN PGP (MESSAGE|SIGNED MESSAGE)-----[\s\S]*-----END PGP (MESSAGE|SIGNATURE)-----/;
        return pgpMessageRegex.test(message);
    },

    // Validate PGP public key format
    validatePGPPublicKey(key) {
        const pgpKeyRegex = /-----BEGIN PGP PUBLIC KEY BLOCK-----[\s\S]*-----END PGP PUBLIC KEY BLOCK-----/;
        return pgpKeyRegex.test(key);
    },

    // Validate passphrase for decryption
    validatePassphrase(passphrase) {
        if (!passphrase) {
            throw new Error('Passphrase is required for decryption');
        }
        return passphrase;
    },

    // Validate key backup file structure
    validateKeyBackup(backup) {
        if (!backup || typeof backup !== 'object') {
            throw new Error('Invalid backup file format');
        }
        
        if (!backup.keys || !backup.keys.private || !backup.keys.public) {
            throw new Error('Backup file missing required keys');
        }
        
        if (!this.validatePGPPublicKey(backup.keys.public)) {
            throw new Error('Invalid public key in backup file');
        }
        
        return true;
    }
};

--- FILE: js/utils/constants.js ---
// Application constants
export const CONSTANTS = {
    // Key generation defaults
    DEFAULT_ALGORITHM: 'ecc',
    DEFAULT_EXPIRATION: 63072000, // 2 years in seconds
    DEFAULT_CURVE: 'curve25519',
    DEFAULT_RSA_BITS: 2048,
    
    // Validation rules
    MIN_PASSPHRASE_LENGTH: 8,
    
    // UI constants
    LOADING_TEXT: 'Processing...',
    
    // Status types
    STATUS: {
        PENDING: 'pending',
        READY: 'ready',
        ERROR: 'error',
        SUCCESS: 'success'
    },
    
    // File extensions
    KEY_FILE_EXTENSION: '.json',
    
    // Time constants
    SECONDS_PER_YEAR: 31536000,
    
    // Error messages
    ERRORS: {
        NO_KEYS: 'No key pair available. Please generate or load keys first.',
        INVALID_EMAIL: 'Please enter a valid email address',
        PASSPHRASE_TOO_SHORT: 'Passphrase must be at least 8 characters long',
        REQUIRED_FIELD: 'This field is required',
        INVALID_KEY_FILE: 'Invalid key file format',
        DECRYPTION_FAILED: 'Failed to decrypt message. Check your passphrase and try again.',
        VERIFICATION_FAILED: 'Signature verification failed',
        ENCRYPTION_FAILED: 'Encryption failed',
        SIGNING_FAILED: 'Signing failed'
    },
    
    // Success messages
    SUCCESS: {
        KEY_GENERATED: 'Key pair generated successfully!',
        KEY_LOADED: 'Key pair loaded successfully!',
        KEY_SAVED: 'Key pair saved successfully!',
        MESSAGE_SIGNED: 'Message signed successfully!',
        MESSAGE_VERIFIED: 'Message verified successfully!',
        MESSAGE_ENCRYPTED: 'Message encrypted successfully!',
        MESSAGE_DECRYPTED: 'Message decrypted successfully!'
    }
};

--- FILE: js/utils/clipboard.js ---
export const Clipboard = {
    // Copy text to clipboard
    async copyToClipboard(text) {
        try {
            // Modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
                return true;
            }
            
            // Fallback for older browsers
            return this.fallbackCopyToClipboard(text);
        } catch (err) {
            console.error('Failed to copy to clipboard:', err);
            return false;
        }
    },

    // Fallback clipboard method for older browsers
    fallbackCopyToClipboard(text) {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            return successful;
        } catch (err) {
            console.error('Fallback copy failed:', err);
            return false;
        }
    },

    // Add copy button to output elements
    addCopyButton(outputElement, textToCopy) {
        // Remove existing copy button if present
        const existingButton = outputElement.querySelector('.copy-btn');
        if (existingButton) {
            existingButton.remove();
        }

        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = '📋 Copy';
        copyBtn.style.cssText = `
            margin-top: 10px;
            padding: 5px 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        `;

        copyBtn.addEventListener('click', async () => {
            const success = await this.copyToClipboard(textToCopy);
            if (success) {
                copyBtn.textContent = '✅ Copied!';
                setTimeout(() => {
                    copyBtn.textContent = '📋 Copy';
                }, 2000);
            } else {
                copyBtn.textContent = '❌ Failed';
                setTimeout(() => {
                    copyBtn.textContent = '📋 Copy';
                }, 2000);
            }
        });

        outputElement.appendChild(copyBtn);
    }
};

--- FILE: js/utils/formatting.js ---
export const Formatting = {
    // Format fingerprint with spaces for readability
    formatFingerprint(fingerprint) {
        if (!fingerprint) return '';
        return fingerprint.replace(/(.{4})/g, '$1 ').trim().toUpperCase();
    },

    // Format date for display
    formatDate(date) {
        if (!date) return '';
        return new Date(date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    },

    // Format key algorithm for display
    formatAlgorithm(algorithm) {
        if (!algorithm) return 'Unknown';
        
        switch(algorithm.toLowerCase()) {
            case 'ecc':
                return 'ECC (Curve25519)';
            case 'rsa2048':
                return 'RSA 2048-bit';
            case 'rsa4096':
                return 'RSA 4096-bit';
            case 'rsa':
                return 'RSA';
            default:
                return algorithm.toUpperCase();
        }
    },

    // Format expiration time for display
    formatExpiration(seconds) {
        if (!seconds || seconds === 0) {
            return 'Never expires';
        }
        
        const years = Math.round(seconds / 31536000);
        return `${years} year${years !== 1 ? 's' : ''}`;
    },

    // Format key usage for display
    formatUsage(usage) {
        if (!usage) return 'None';
        
        const usages = [];
        if (usage.sign) usages.push('Sign');
        if (usage.encrypt) usages.push('Encrypt');
        if (usage.certify) usages.push('Certify');
        
        return usages.join(', ') || 'None selected';
    },

    // Format file size for display
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },

    // Truncate text for display
    truncateText(text, maxLength = 50) {
        if (!text || text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
    },

    // Format PGP message for display (truncated)
    formatPGPMessagePreview(message, maxLines = 5) {
        if (!message) return '';
        
        const lines = message.split('\n');
        if (lines.length <= maxLines) return message;
        
        return lines.slice(0, maxLines).join('\n') + '\n... (truncated)';
    },

    // Clean filename for download
    sanitizeFilename(filename) {
        return filename
            .replace(/[^a-z0-9.-]/gi, '-')
            .replace(/-+/g, '-')
            .toLowerCase();
    },

    // Generate filename for key backup
    generateKeyBackupFilename(name, email) {
        const timestamp = Date.now();
        const safeName = this.sanitizeFilename(name || 'user');
        return `pgp-keys-${safeName}-${timestamp}.json`;
    }
};

--- FILE: js/pki.js ---
1

// ====================

2

// MODULAR ARCHITECTURE

3

// ====================

4

​

5

// 1. STATE MANAGEMENT

6

class AppState {

7

    constructor() {

8

        this.keyPair = null;

9

        this.isReady = false;

10

        this.listeners = {};

11

    }

12

​

13

    setKeyPair(keyPair) {

14

        this.keyPair = keyPair;

--- FILE: js/modules/decrypt.js ---
import { CONSTANTS } from '../utils/constants.js';
import { Validation } from '../utils/validation.js';
import { Clipboard } from '../utils/clipboard.js';

export class Decrypt {
    constructor(keyManager, cryptoOps) {
        this.keyManager = keyManager;
        this.cryptoOps = cryptoOps;
    }

    // Initialize decrypt functionality
    init() {
        this.setupEventListeners();
        this.updateUI();
    }

    // Setup event listeners
    setupEventListeners() {
        // Decrypt button
        document.getElementById('decryptBtn').addEventListener('click', () => this.handleDecrypt());
    }

    // Handle message decryption
    async handleDecrypt() {
        const decryptBtn = document.getElementById('decryptBtn');
        const messageInput = document.getElementById('messageToDecrypt');
        const output = document.getElementById('decryptOutput');

        try {
            // Validate encrypted message
            const encryptedMessage = messageInput.value.trim();
            if (!encryptedMessage) {
                throw new Error('Please enter an encrypted message to decrypt');
            }

            // Check if keys are available
            if (!this.keyManager.hasKeys()) {
                throw new Error('No keys available. Please generate or load keys first.');
            }

            // Validate PGP message format
            if (!encryptedMessage.includes('-----BEGIN PGP MESSAGE-----')) {
                throw new Error('Invalid PGP message format. Please ensure you\'ve pasted a complete encrypted PGP message.');
            }

            // Set loading state
            decryptBtn.disabled = true;
            decryptBtn.textContent = 'Decrypting...';
            this.updateStatus('pending', 'Decrypting Message...');

            // Get private key and passphrase
            const privateKey = this.keyManager.getPrivateKey();
            const passphrase = this.keyManager.getPassphrase();

            if (!passphrase) {
                throw new Error('Passphrase is required for decryption. Please ensure your key is properly loaded.');
            }

            // Decrypt the message
            const decryptedMessage = await this.cryptoOps.decryptMessage(encryptedMessage, privateKey, passphrase);

            // Show success result
            const resultMessage = `✅ Message decrypted successfully!\n\nDecrypted message:\n${decryptedMessage}`;
            this.showOutput(output, resultMessage, 'success');
            this.updateStatus('ready', 'Message Decrypted');

            // Add copy button for decrypted content
            this.addCopyButton(output, decryptedMessage);

        } catch (error) {
            console.error('Decrypt failed:', error);
            
            // Provide helpful error messages
            let errorMessage = error.message;
            if (error.message.includes('Incorrect key passphrase')) {
                errorMessage = 'Incorrect passphrase. Please check your key passphrase.';
            } else if (error.message.includes('No decryption keys found')) {
                errorMessage = 'This message was not encrypted for your key. You cannot decrypt it.';
            } else if (error.message.includes('Error decrypting message')) {
                errorMessage = 'Failed to decrypt message. Please check that:\n• The message is a valid PGP encrypted message\n• The message was encrypted for your public key\n• Your private key and passphrase are correct';
            }
            
            this.showOutput(output, `Decrypt failed: ${errorMessage}`, 'error');
            this.updateStatus('error', 'Decrypt Failed');
        } finally {
            decryptBtn.disabled = false;
            decryptBtn.textContent = 'Decrypt Message';
        }
    }

    // Update UI based on current state
    updateUI() {
        const hasKeys = this.keyManager.hasKeys();
        
        // Update status
        if (hasKeys) {
            this.updateStatus('ready', 'Ready to Decrypt');
        } else {
            this.updateStatus('pending', 'Keys Required');
        }

        // Enable/disable decrypt button
        document.getElementById('decryptBtn').disabled = !hasKeys;
    }

    // Update status indicator
    updateStatus(status, text) {
        const statusEl = document.getElementById('decryptStatus');
        statusEl.className = `status ${status}`;
        statusEl.textContent = text;
    }

    // Show output with styling
    showOutput(outputEl, content, type = 'success') {
        outputEl.className = `output ${type}`;
        outputEl.textContent = content;
        outputEl.style.display = 'block';
    }

    // Add copy button to output
    addCopyButton(outputEl, decryptedContent) {
        // Remove existing copy button if present
        const existingBtn = outputEl.querySelector('.copy-btn');
        if (existingBtn) {
            existingBtn.remove();
        }

        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy Decrypted Message';
        copyBtn.style.marginTop = '10px';
        
        copyBtn.addEventListener('click', async () => {
            const success = await Clipboard.copyToClipboard(decryptedContent);
            if (success) {
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Decrypted Message';
                }, 2000);
            } else {
                copyBtn.textContent = 'Copy Failed';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Decrypted Message';
                }, 2000);
            }
        });

        outputEl.appendChild(copyBtn);
    }

    // Get current operation status
    getStatus() {
        return {
            hasKeys: this.keyManager.hasKeys(),
            canDecrypt: this.keyManager.hasKeys() && this.keyManager.getPassphrase()
        };
    }

    // Reset all inputs and outputs
    reset() {
        document.getElementById('messageToDecrypt').value = '';
        document.getElementById('decryptOutput').style.display = 'none';
        this.updateUI();
    }
}

--- FILE: js/modules/cryptoOps.js ---
import { CONSTANTS } from '../utils/constants.js';
import { Validation } from '../utils/validation.js';

export class CryptoOps {
    constructor(keyManager) {
        this.keyManager = keyManager;
    }

    // Encrypt message
    async encryptMessage(message, recipientPublicKey = null) {
        try {
            Validation.validateMessage(message);

            let publicKey;
            
            if (recipientPublicKey) {
                // Use provided public key
                if (!Validation.validatePGPPublicKey(recipientPublicKey)) {
                    throw new Error('Invalid public key format');
                }
                publicKey = await openpgp.readKey({ armoredKey: recipientPublicKey });
            } else {
                // Use own public key
                const keyPair = this.keyManager.getCurrentKeyPair();
                if (!keyPair) {
                    throw new Error(CONSTANTS.ERRORS.NO_KEYS);
                }
                publicKey = keyPair.publicKeyObj;
            }

            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ text: message }),
                encryptionKeys: publicKey,
                format: 'armored'
            });

            return encrypted;

        } catch (error) {
            console.error('Encryption failed:', error);
            throw new Error(`${CONSTANTS.ERRORS.ENCRYPTION_FAILED}: ${error.message}`);
        }
    }

    // Decrypt message
    async decryptMessage(encryptedMessage, passphrase) {
        try {
            const keyPair = this.keyManager.getCurrentKeyPair();
            if (!keyPair) {
                throw new Error(CONSTANTS.ERRORS.NO_KEYS);
            }

            Validation.validatePassphrase(passphrase);

            if (!Validation.validatePGPMessage(encryptedMessage)) {
                throw new Error('Invalid encrypted message format');
            }

            // Decrypt the private key with passphrase
            const privateKey = await openpgp.decryptKey({
                privateKey: keyPair.privateKeyObj,
                passphrase: passphrase
            });

            // Read the encrypted message
            const message = await openpgp.readMessage({
                armoredMessage: encryptedMessage
            });

            // Decrypt the message
            const { data: decrypted } = await openpgp.decrypt({
                message: message,
                decryptionKeys: privateKey,
                format: 'utf8'
            });

            return decrypted;

        } catch (error) {
            console.error('Decryption failed:', error);
            throw new Error(`${CONSTANTS.ERRORS.DECRYPTION_FAILED}: ${error.message}`);
        }
    }

    // Sign message
    async signMessage(message, passphrase) {
        try {
            const keyPair = this.keyManager.getCurrentKeyPair();
            if (!keyPair) {
                throw new Error(CONSTANTS.ERRORS.NO_KEYS);
            }

            Validation.validateMessage(message);
            Validation.validatePassphrase(passphrase);

            // Decrypt the private key with passphrase
            const privateKey = await openpgp.decryptKey({
                privateKey: keyPair.privateKeyObj,
                passphrase: passphrase
            });

            // Create and sign the message
            const signed = await openpgp.sign({
                message: await openpgp.createCleartextMessage({ text: message }),
                signingKeys: privateKey,
                format: 'armored'
            });

            return signed;

        } catch (error) {
            console.error('Signing failed:', error);
            throw new Error(`${CONSTANTS.ERRORS.SIGNING_FAILED}: ${error.message}`);
        }
    }

    // Verify signed message
    async verifyMessage(signedMessage, signerPublicKey = null) {
        try {
            if (!Validation.validatePGPMessage(signedMessage)) {
                throw new Error('Invalid signed message format');
            }

            let publicKey;
            
            if (signerPublicKey) {
                // Use provided public key
                if (!Validation.validatePGPPublicKey(signerPublicKey)) {
                    throw new Error('Invalid public key format');
                }
                publicKey = await openpgp.readKey({ armoredKey: signerPublicKey });
            } else {
                // Use own public key
                const keyPair = this.keyManager.getCurrentKeyPair();
                if (!keyPair) {
                    throw new Error(CONSTANTS.ERRORS.NO_KEYS);
                }
                publicKey = keyPair.publicKeyObj;
            }

            // Read the signed message
            const message = await openpgp.readCleartextMessage({
                cleartextMessage: signedMessage
            });

            // Verify the signature
            const verificationResult = await openpgp.verify({
                message: message,
                verificationKeys: publicKey,
                format: 'utf8'
            });

            // Check if signature is valid
            const { verified } = verificationResult.signatures[0];
            await verified; // This will throw if verification fails

            return {
                verified: true,
                data: verificationResult.data,
                signatures: verificationResult.signatures
            };

        } catch (error) {
            console.error('Verification failed:', error);
            
            // Check if it's a verification failure vs other error
            if (error.message.includes('Signature verification failed')) {
                return {
                    verified: false,
                    error: 'Signature verification failed - the message may have been tampered with or signed by a different key'
                };
            }
            
            throw new Error(`${CONSTANTS.ERRORS.VERIFICATION_FAILED}: ${error.message}`);
        }
    }

    // Sign and encrypt message (combined operation)
    async signAndEncryptMessage(message, passphrase, recipientPublicKey = null) {
        try {
            const keyPair = this.keyManager.getCurrentKeyPair();
            if (!keyPair) {
                throw new Error(CONSTANTS.ERRORS.NO_KEYS);
            }

            Validation.validateMessage(message);
            Validation.validatePassphrase(passphrase);

            // Decrypt the private key with passphrase
            const privateKey = await openpgp.decryptKey({
                privateKey: keyPair.privateKeyObj,
                passphrase: passphrase
            });

            let publicKey;
            if (recipientPublicKey) {
                if (!Validation.validatePGPPublicKey(recipientPublicKey)) {
                    throw new Error('Invalid public key format');
                }
                publicKey = await openpgp.readKey({ armoredKey: recipientPublicKey });
            } else {
                publicKey = keyPair.publicKeyObj;
            }

            // Sign and encrypt the message
            const signedAndEncrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ text: message }),
                encryptionKeys: publicKey,
                signingKeys: privateKey,
                format: 'armored'
            });

            return signedAndEncrypted;

        } catch (error) {
            console.error('Sign and encrypt failed:', error);
            throw new Error(`Sign and encrypt failed: ${error.message}`);
        }
    }

    // Decrypt and verify message (combined operation)
    async decryptAndVerifyMessage(encryptedMessage, passphrase, signerPublicKey = null) {
        try {
            const keyPair = this.keyManager.getCurrentKeyPair();
            if (!keyPair) {
                throw new Error(CONSTANTS.ERRORS.NO_KEYS);
            }

            Validation.validatePassphrase(passphrase);

            // Decrypt the private key with passphrase
            const privateKey = await openpgp.decryptKey({
                privateKey: keyPair.privateKeyObj,
                passphrase: passphrase
            });

            let verificationKeys;
            if (signerPublicKey) {
                if (!Validation.validatePGPPublicKey(signerPublicKey)) {
                    throw new Error('Invalid public key format');
                }
                verificationKeys = await openpgp.readKey({ armoredKey: signerPublicKey });
            } else {
                verificationKeys = keyPair.publicKeyObj;
            }

            // Read the encrypted message
            const message = await openpgp.readMessage({
                armoredMessage: encryptedMessage
            });

            // Decrypt and verify the message
            const result = await openpgp.decrypt({
                message: message,
                decryptionKeys: privateKey,
                verificationKeys: verificationKeys,
                format: 'utf8'
            });

            // Check signature verification
            const signatureValid = result.signatures.length > 0;
            let signatureVerified = false;
            
            if (signatureValid) {
                try {
                    const { verified } = result.signatures[0];
                    await verified;
                    signatureVerified = true;
                } catch (e) {
                    console.warn('Signature verification failed:', e);
                }
            }

            return {
                data: result.data,
                signatureValid,
                signatureVerified,
                signatures: result.signatures
            };

        } catch (error) {
            console.error('Decrypt and verify failed:', error);
            throw new Error(`Decrypt and verify failed: ${error.message}`);
        }
    }
}

--- FILE: js/modules/encrypt.js ---
import { CONSTANTS } from '../utils/constants.js';
import { Validation } from '../utils/validation.js';
import { Clipboard } from '../utils/clipboard.js';

export class Encrypt {
    constructor(keyManager, cryptoOps) {
        this.keyManager = keyManager;
        this.cryptoOps = cryptoOps;
        this.useCustomPublicKey = false;
    }

    // Initialize encrypt functionality
    init() {
        this.setupEventListeners();
        this.updateUI();
    }

    // Setup event listeners
    setupEventListeners() {
        // Encrypt button
        document.getElementById('encryptBtn').addEventListener('click', () => this.handleEncrypt());

        // Toggle custom public key
        document.getElementById('toggleEncryptPublicKeyBtn').addEventListener('click', () => {
            this.toggleCustomPublicKey();
        });
    }

    // Toggle custom public key input
    toggleCustomPublicKey() {
        this.useCustomPublicKey = !this.useCustomPublicKey;
        
        const container = document.getElementById('encryptCustomPublicKeyContainer');
        const button = document.getElementById('toggleEncryptPublicKeyBtn');
        
        if (this.useCustomPublicKey) {
            container.style.display = 'block';
            button.textContent = 'Use Own Public Key';
        } else {
            container.style.display = 'none';
            button.textContent = 'Use Custom Public Key';
        }

        this.updateUI();
    }

    // Handle message encryption
    async handleEncrypt() {
        const encryptBtn = document.getElementById('encryptBtn');
        const messageInput = document.getElementById('messageToEncrypt');
        const customPublicKeyInput = document.getElementById('encryptCustomPublicKey');
        const output = document.getElementById('encryptOutput');

        try {
            // Validate message
            const message = messageInput.value.trim();
            if (!message) {
                throw new Error('Please enter a message to encrypt');
            }

            // Determine which public key to use
            let publicKey;
            let recipientInfo = 'yourself';
            
            if (this.useCustomPublicKey) {
                const customPublicKey = customPublicKeyInput.value.trim();
                if (!customPublicKey) {
                    throw new Error('Please enter a recipient\'s public key or switch to use your own key');
                }
                publicKey = customPublicKey;
                recipientInfo = 'recipient';
            } else {
                if (!this.keyManager.hasKeys()) {
                    throw new Error('No keys available. Please generate/load keys or use a custom public key.');
                }
                publicKey = this.keyManager.getPublicKey();
            }

            // Set loading state
            encryptBtn.disabled = true;
            encryptBtn.textContent = 'Encrypting...';
            this.updateStatus('pending', 'Encrypting Message...');

            // Encrypt the message
            const encryptedMessage = await this.cryptoOps.encryptMessage(message, publicKey);

            // Show success result
            const resultMessage = `✅ Message encrypted successfully for ${recipientInfo}!\n\nEncrypted message:\n${encryptedMessage}`;
            this.showOutput(output, resultMessage, 'success');
            this.updateStatus('ready', 'Message Encrypted');

            // Add copy button
            this.addCopyButton(output, encryptedMessage);

        } catch (error) {
            console.error('Encrypt failed:', error);
            this.showOutput(output, `Encrypt failed: ${error.message}`, 'error');
            this.updateStatus('error', 'Encrypt Failed');
        } finally {
            encryptBtn.disabled = false;
            encryptBtn.textContent = 'Encrypt Message';
        }
    }

    // Update UI based on current state
    updateUI() {
        const hasKeys = this.keyManager.hasKeys();
        
        // Update status
        if (hasKeys || this.useCustomPublicKey) {
            this.updateStatus('ready', 'Ready to Encrypt');
        } else {
            this.updateStatus('pending', 'Keys Required');
        }

        // Enable/disable encrypt button
        const encryptBtn = document.getElementById('encryptBtn');
        encryptBtn.disabled = !hasKeys && !this.useCustomPublicKey;
    }

    // Update status indicator
    updateStatus(status, text) {
        const statusEl = document.getElementById('encryptStatus');
        statusEl.className = `status ${status}`;
        statusEl.textContent = text;
    }

    // Show output with styling
    showOutput(outputEl, content, type = 'success') {
        outputEl.className = `output ${type}`;
        outputEl.textContent = content;
        outputEl.style.display = 'block';
    }

    // Add copy button to output
    addCopyButton(outputEl, encryptedContent) {
        // Remove existing copy button if present
        const existingBtn = outputEl.querySelector('.copy-btn');
        if (existingBtn) {
            existingBtn.remove();
        }

        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy Encrypted Message';
        copyBtn.style.marginTop = '10px';
        
        copyBtn.addEventListener('click', async () => {
            const success = await Clipboard.copyToClipboard(encryptedContent);
            if (success) {
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Encrypted Message';
                }, 2000);
            } else {
                copyBtn.textContent = 'Copy Failed';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Encrypted Message';
                }, 2000);
            }
        });

        outputEl.appendChild(copyBtn);
    }

    // Get current operation status
    getStatus() {
        return {
            useCustomPublicKey: this.useCustomPublicKey,
            hasKeys: this.keyManager.hasKeys()
        };
    }

    // Reset all inputs and outputs
    reset() {
        document.getElementById('messageToEncrypt').value = 'This is a secret message that will be encrypted!';
        document.getElementById('encryptCustomPublicKey').value = '';
        document.getElementById('encryptOutput').style.display = 'none';
        
        this.useCustomPublicKey = false;
        this.toggleCustomPublicKey();
        
        this.updateUI();
    }
}

--- FILE: js/modules/keyManager.js ---
import { CONSTANTS } from '../utils/constants.js';
import { Validation } from '../utils/validation.js';
import { Formatting } from '../utils/formatting.js';

export class KeyManager {
    constructor() {
        this.currentKeyPair = null;
        this.advancedConfig = {
            algorithm: CONSTANTS.DEFAULT_ALGORITHM,
            keySize: null,
            expiration: CONSTANTS.DEFAULT_EXPIRATION,
            usage: {
                sign: true,
                encrypt: true,
                certify: true
            },
            comment: ''
        };
    }

    // Generate new key pair
    async generateKeyPair(userInfo) {
        try {
            const config = this.advancedConfig;
            
            // Build key generation options
            const keyOptions = {
                type: config.algorithm === 'ecc' ? 'ecc' : 'rsa',
                userIDs: [{ 
                    name: userInfo.name, 
                    email: userInfo.email, 
                    comment: config.comment 
                }],
                passphrase: userInfo.passphrase,
                format: 'armored'
            };

            // Set algorithm-specific options
            if (config.algorithm === 'ecc') {
                keyOptions.curve = CONSTANTS.DEFAULT_CURVE;
            } else {
                keyOptions.rsaBits = config.keySize || CONSTANTS.DEFAULT_RSA_BITS;
            }

            // Set expiration
            if (config.expiration > 0) {
                keyOptions.keyExpirationTime = config.expiration;
            }

            console.log('Generating key with options:', keyOptions);

            // Generate the key pair
            const { privateKey, publicKey } = await openpgp.generateKey(keyOptions);

            // Parse keys for metadata
            const privateKeyObj = await openpgp.readPrivateKey({ armoredKey: privateKey });
            const publicKeyObj = await openpgp.readKey({ armoredKey: publicKey });

            const keyPair = {
                privateKey,
                publicKey,
                privateKeyObj,
                publicKeyObj,
                metadata: {
                    keyId: publicKeyObj.getKeyIDs()[0].toHex().toUpperCase(),
                    fingerprint: publicKeyObj.getFingerprint(),
                    algorithm: config.algorithm.toUpperCase(),
                    created: publicKeyObj.getCreationTime(),
                    userIds: publicKeyObj.getUserIDs()
                }
            };

            this.currentKeyPair = keyPair;
            return keyPair;

        } catch (error) {
            console.error('Key generation failed:', error);
            throw new Error(`Key generation failed: ${error.message}`);
        }
    }

    // Load key pair from backup
    async loadKeyPair(backup) {
        try {
            Validation.validateKeyBackup(backup);

            // Parse keys
            const privateKeyObj = await openpgp.readPrivateKey({ armoredKey: backup.keys.private });
            const publicKeyObj = await openpgp.readKey({ armoredKey: backup.keys.public });

            const keyPair = {
                privateKey: backup.keys.private,
                publicKey: backup.keys.public,
                privateKeyObj,
                publicKeyObj,
                metadata: backup.metadata || {
                    keyId: publicKeyObj.getKeyIDs()[0].toHex().toUpperCase(),
                    fingerprint: publicKeyObj.getFingerprint(),
                    algorithm: 'LOADED',
                    created: publicKeyObj.getCreationTime(),
                    userIds: publicKeyObj.getUserIDs()
                }
            };

            this.currentKeyPair = keyPair;
            return keyPair;

        } catch (error) {
            throw new Error(`Failed to load key pair: ${error.message}`);
        }
    }

    // Create key backup for download
    createKeyBackup(userInfo) {
        if (!this.currentKeyPair) {
            throw new Error(CONSTANTS.ERRORS.NO_KEYS);
        }

        const backup = {
            version: '1.0',
            created: new Date().toISOString(),
            userInfo: {
                name: userInfo.name,
                email: userInfo.email
            },
            config: {
                algorithm: this.advancedConfig.algorithm,
                keySize: this.advancedConfig.keySize,
                comment: this.advancedConfig.comment
            },
            keys: {
                private: this.currentKeyPair.privateKey,
                public: this.currentKeyPair.publicKey
            },
            metadata: this.currentKeyPair.metadata
        };

        return JSON.stringify(backup, null, 2);
    }

    // Get current key pair
    getCurrentKeyPair() {
        return this.currentKeyPair;
    }

    // Check if keys are available
    hasKeys() {
        return this.currentKeyPair !== null;
    }

    // Update advanced configuration
    updateAdvancedConfig(newConfig) {
        this.advancedConfig = { ...this.advancedConfig, ...newConfig };
    }

    // Get advanced configuration
    getAdvancedConfig() {
        return { ...this.advancedConfig };
    }

    // Get formatted key information
    getFormattedKeyInfo() {
        if (!this.currentKeyPair) {
            return null;
        }

        const metadata = this.currentKeyPair.metadata;
        return {
            keyId: metadata.keyId,
            fingerprint: Formatting.formatFingerprint(metadata.fingerprint),
            algorithm: Formatting.formatAlgorithm(metadata.algorithm),
            created: Formatting.formatDate(metadata.created),
            userIds: metadata.userIds
        };
    }

    // Clear current keys
    clearKeys() {
        this.currentKeyPair = null;
    }
}

--- FILE: js/modules/signVerify.js ---
import { CONSTANTS } from '../utils/constants.js';
import { Validation } from '../utils/validation.js';
import { Clipboard } from '../utils/clipboard.js';

export class SignVerify {
    constructor(keyManager, cryptoOps) {
        this.keyManager = keyManager;
        this.cryptoOps = cryptoOps;
        this.currentMode = 'sign';
        this.useCustomPublicKey = false;
    }

    // Initialize sign & verify functionality
    init() {
        this.setupEventListeners();
        this.updateUI();
    }

    // Setup event listeners
    setupEventListeners() {
        // Tab switching
        document.getElementById('signTab').addEventListener('click', () => this.switchTab('sign'));
        document.getElementById('verifyTab').addEventListener('click', () => this.switchTab('verify'));

        // Sign button
        document.getElementById('signBtnNew').addEventListener('click', () => this.handleSign());

        // Verify button
        document.getElementById('verifyBtn').addEventListener('click', () => this.handleVerify());

        // Toggle custom public key for verification
        document.getElementById('toggleVerifyPublicKeyBtn').addEventListener('click', () => {
            this.toggleCustomPublicKey();
        });
    }

    // Switch between sign and verify tabs
    switchTab(mode) {
        this.currentMode = mode;

        // Update tab buttons
        document.getElementById('signTab').classList.toggle('active', mode === 'sign');
        document.getElementById('verifyTab').classList.toggle('active', mode === 'verify');

        // Update tab content
        document.getElementById('signMode').classList.toggle('active', mode === 'sign');
        document.getElementById('verifyMode').classList.toggle('active', mode === 'verify');

        this.updateUI();
    }

    // Toggle custom public key input for verification
    toggleCustomPublicKey() {
        this.useCustomPublicKey = !this.useCustomPublicKey;
        
        const container = document.getElementById('verifyCustomPublicKeyContainer');
        const button = document.getElementById('toggleVerifyPublicKeyBtn');
        
        if (this.useCustomPublicKey) {
            container.style.display = 'block';
            button.textContent = 'Use Own Public Key';
        } else {
            container.style.display = 'none';
            button.textContent = 'Use Custom Public Key';
        }
    }

    // Handle message signing
    async handleSign() {
        const signBtn = document.getElementById('signBtnNew');
        const messageInput = document.getElementById('messageToSignNew');
        const output = document.getElementById('signOutputNew');

        try {
            // Validate message
            const message = messageInput.value.trim();
            if (!message) {
                throw new Error('Please enter a message to sign');
            }

            // Check if keys are available
            if (!this.keyManager.hasKeys()) {
                throw new Error('No keys available. Please generate or load keys first.');
            }

            // Set loading state
            signBtn.disabled = true;
            signBtn.textContent = 'Signing...';
            this.updateStatus('pending', 'Signing Message...');

            // Sign the message
            const signedMessage = await this.cryptoOps.signMessage(message);

            // Show success result
            this.showOutput(output, signedMessage, 'success');
            this.updateStatus('ready', 'Message Signed');

            // Add copy button
            this.addCopyButton(output, signedMessage);

        } catch (error) {
            console.error('Sign failed:', error);
            this.showOutput(output, `Sign failed: ${error.message}`, 'error');
            this.updateStatus('error', 'Sign Failed');
        } finally {
            signBtn.disabled = false;
            signBtn.textContent = 'Sign Message';
        }
    }

    // Handle message verification
    async handleVerify() {
        const verifyBtn = document.getElementById('verifyBtn');
        const signedMessageInput = document.getElementById('signedMessageToVerify');
        const customPublicKeyInput = document.getElementById('verifyCustomPublicKey');
        const output = document.getElementById('verifyOutput');

        try {
            // Validate signed message
            const signedMessage = signedMessageInput.value.trim();
            if (!signedMessage) {
                throw new Error('Please enter a signed message to verify');
            }

            // Determine which public key to use
            let publicKey;
            if (this.useCustomPublicKey) {
                const customPublicKey = customPublicKeyInput.value.trim();
                if (!customPublicKey) {
                    throw new Error('Please enter a custom public key or switch to use your own key');
                }
                publicKey = customPublicKey;
            } else {
                if (!this.keyManager.hasKeys()) {
                    throw new Error('No keys available. Please generate/load keys or use a custom public key.');
                }
                publicKey = this.keyManager.getPublicKey();
            }

            // Set loading state
            verifyBtn.disabled = true;
            verifyBtn.textContent = 'Verifying...';
            this.updateStatus('pending', 'Verifying Message...');

            // Verify the message
            const verificationResult = await this.cryptoOps.verifyMessage(signedMessage, publicKey);

            // Show verification result
            if (verificationResult.verified) {
                const resultMessage = `✅ Signature is VALID\n\nOriginal message:\n${verificationResult.message}\n\nSigned by: ${verificationResult.signerInfo || 'Unknown'}`;
                this.showOutput(output, resultMessage, 'success');
                this.updateStatus('ready', 'Signature Valid');
            } else {
                const resultMessage = `❌ Signature is INVALID\n\nReason: ${verificationResult.error || 'Signature verification failed'}`;
                this.showOutput(output, resultMessage, 'error');
                this.updateStatus('error', 'Signature Invalid');
            }

        } catch (error) {
            console.error('Verify failed:', error);
            this.showOutput(output, `Verify failed: ${error.message}`, 'error');
            this.updateStatus('error', 'Verify Failed');
        } finally {
            verifyBtn.disabled = false;
            verifyBtn.textContent = 'Verify Message';
        }
    }

    // Update UI based on current state
    updateUI() {
        const hasKeys = this.keyManager.hasKeys();
        
        // Update status
        if (hasKeys) {
            this.updateStatus('ready', 'Keys Available');
        } else {
            this.updateStatus('pending', 'Keys Required');
        }

        // Enable/disable buttons based on key availability
        document.getElementById('signBtnNew').disabled = !hasKeys;
        
        // For verify, enable if we have keys OR if using custom public key
        const verifyBtn = document.getElementById('verifyBtn');
        verifyBtn.disabled = !hasKeys && !this.useCustomPublicKey;
    }

    // Update status indicator
    updateStatus(status, text) {
        const statusEl = document.getElementById('signVerifyStatus');
        statusEl.className = `status ${status}`;
        statusEl.textContent = text;
    }

    // Show output with styling
    showOutput(outputEl, content, type = 'success') {
        outputEl.className = `output ${type}`;
        outputEl.textContent = content;
        outputEl.style.display = 'block';
    }

    // Add copy button to output
    addCopyButton(outputEl, content) {
        // Remove existing copy button if present
        const existingBtn = outputEl.querySelector('.copy-btn');
        if (existingBtn) {
            existingBtn.remove();
        }

        // Create copy button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'copy-btn';
        copyBtn.textContent = 'Copy to Clipboard';
        copyBtn.style.marginTop = '10px';
        
        copyBtn.addEventListener('click', async () => {
            const success = await Clipboard.copyToClipboard(content);
            if (success) {
                copyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy to Clipboard';
                }, 2000);
            } else {
                copyBtn.textContent = 'Copy Failed';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy to Clipboard';
                }, 2000);
            }
        });

        outputEl.appendChild(copyBtn);
    }

    // Get current operation status
    getStatus() {
        return {
            currentMode: this.currentMode,
            useCustomPublicKey: this.useCustomPublicKey,
            hasKeys: this.keyManager.hasKeys()
        };
    }

    // Reset all inputs and outputs
    reset() {
        document.getElementById('messageToSignNew').value = '';
        document.getElementById('signedMessageToVerify').value = '';
        document.getElementById('verifyCustomPublicKey').value = '';
        
        document.getElementById('signOutputNew').style.display = 'none';
        document.getElementById('verifyOutput').style.display = 'none';
        
        this.useCustomPublicKey = false;
        this.toggleCustomPublicKey();
        
        this.updateUI();
    }
}

